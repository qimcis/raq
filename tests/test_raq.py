# Tests were generated by AI

from __future__ import annotations

import unittest

from raq import parse_definitions, parse_query, evaluate


def rows_as_set(rel):
    return {tuple(rel.rows[i][c] for c in rel.header) for i in range(len(rel.rows))}


class TestRAQ(unittest.TestCase):
    def assertRelation(self, rel, header, rows):
        self.assertEqual(rel.header, header, msg=f"Header mismatch: got {rel.header}")
        got = rows_as_set(rel)
        exp = set(rows)
        self.assertEqual(got, exp)

    def test_parse_definitions_and_dedup(self):
        txt = (
            "Employees (EID, Name, Age) = {\n"
            "  E1, John, 32\n"
            "  E2, Alice, 28\n"
            "  E3, Bob, 29\n"
            "  E1, John, 32\n"  # duplicate
            "}\n"
        )
        rels = parse_definitions(txt)
        self.assertIn("Employees", rels)
        emp = rels["Employees"]
        self.assertEqual(emp.header, ["EID", "Name", "Age"]) 
        # dedup => 3 rows
        self.assertEqual(len(emp.rows), 3)

    def test_selection_basic(self):
        txt = (
            "Employees (EID, Name, Age) = {\n"
            "  E1, John, 32\n"
            "  E2, Alice, 28\n"
            "}\n"
        )
        rels = parse_definitions(txt)
        ast = parse_query("σ Age > 30 (Employees)")
        res = evaluate(ast, rels)
        self.assertRelation(res, ["EID", "Name", "Age"], [("E1", "John", 32)])

    def test_projection(self):
        txt = (
            "Employees (EID, Name, Age) = {\n"
            "  E1, John, 32\n"
            "  E2, Alice, 28\n"
            "  E3, Bob, 29\n"
            "}\n"
        )
        rels = parse_definitions(txt)
        ast = parse_query("π Name (σ Age > 28 (Employees))")
        res = evaluate(ast, rels)
        self.assertRelation(res, ["Name"], [("John",), ("Bob",)])

    def test_natural_join(self):
        txt = (
            "L (A, B) = {\n  1, x\n  2, y\n}\n"
            "R (B, C) = {\n  x, 10\n  z, 20\n}\n"
        )
        rels = parse_definitions(txt)
        ast = parse_query("L ⋈ R")
        res = evaluate(ast, rels)
        self.assertRelation(res, ["A", "B", "C"], [(1, "x", 10)])

    def test_theta_join_variants(self):
        txt = (
            "Employees (EID, Name, Age) = {\n  E1, John, 32\n  E2, Alice, 28\n  E3, Bob, 29\n}\n"
            "EmpDept (EID, Dept) = {\n  E1, Sales\n  E2, HR\n  E3, Sales\n}\n"
        )
        rels = parse_definitions(txt)
        queries = [
            "Employees ⋈[left.EID = right.EID] EmpDept",
            "join [left.EID = right.EID] (Employees, EmpDept)",
            "join(Employees, EmpDept, left.EID = right.EID)",
        ]
        for q in queries:
            ast = parse_query(q)
            res = evaluate(ast, rels)
            self.assertEqual(res.header, ["EID", "Name", "Age", "EID_right", "Dept"])  # schema with suffix
            self.assertEqual(len(res.rows), 3)

    def test_qualifiers(self):
        txt = (
            "L (EID, Val) = {\n  E1, 1\n  E2, 2\n}\n"
            "R (EID, Val) = {\n  E1, 1\n  E3, 3\n}\n"
        )
        rels = parse_definitions(txt)
        # Use unqualified/suffixed names in selection after join
        ast = parse_query("σ (EID = EID_right and Val = Val_right) (L ⋈[left.EID = right.EID] R)")
        res = evaluate(ast, rels)
        # Only E1 matches; theta join duplicates right.EID as EID_right
        self.assertRelation(res, ["EID", "Val", "EID_right", "Val_right"], [("E1", 1, "E1", 1)])

    def test_set_ops_infix_and_functional(self):
        txt = (
            "R1 (A, B) = {\n  1, 2\n  3, 4\n}\n"
            "R2 (B, A) = {\n  2, 1\n  4, 3\n  5, 6\n}\n"
        )
        rels = parse_definitions(txt)
        # Union (dedup and reorder right)
        res = evaluate(parse_query("R1 ∪ R2"), rels)
        self.assertRelation(res, ["A", "B"], [(1, 2), (3, 4), (6, 5)])
        # Intersect
        res = evaluate(parse_query("R1 ∩ R2"), rels)
        self.assertRelation(res, ["A", "B"], [(1, 2), (3, 4)])
        # Minus
        res = evaluate(parse_query("R1 - R2"), rels)
        self.assertRelation(res, ["A", "B"], [])
        # Functional forms
        res = evaluate(parse_query("union(R1, R2)"), rels)
        self.assertEqual(set(res.header), {"A", "B"})
        res = evaluate(parse_query("intersect(R1, R2)"), rels)
        self.assertEqual(set(res.header), {"A", "B"})
        res = evaluate(parse_query("minus(R1, R2)"), rels)
        self.assertEqual(set(res.header), {"A", "B"})

    def test_set_ops_schema_mismatch_raises(self):
        txt = (
            "A (X) = {\n  1\n}\n"
            "B (Y) = {\n  1\n}\n"
        )
        rels = parse_definitions(txt)
        with self.assertRaises(Exception):
            evaluate(parse_query("A ∪ B"), rels)

    def test_unary_minus_variants(self):
        txt = (
            "R (Age) = {\n  1\n  -1\n  0\n}\n"
        )
        rels = parse_definitions(txt)
        # Debug: ensure tokens are as expected
        from raq.tokens import tokenize
        # print for debug: tokens for predicate
        _toks = tokenize('Age = -1')
        # print('TOKS pred only:', _toks)
        full = tokenize('σ Age = -1 (R)')
        # print('TOKS full expr:', full)
        ast = parse_query("σ Age = -1 (R)")
        # print('AST:', ast)
        import raq.predicate as pm
        # print('class identity eq:', pm.PUnary is type(ast.predicate.right), type(ast.predicate.right), pm.PUnary)
        res = evaluate(ast, rels)
        self.assertRelation(res, ["Age"], [(-1,)])
        res = evaluate(parse_query("σ -Age > 0 (R)"), rels)
        self.assertRelation(res, ["Age"], [(-1,)])
        res = evaluate(parse_query("σ -(Age) < -0.5 (R)"), rels)
        self.assertRelation(res, ["Age"], [(1,)])

    def test_parentheses_in_predicate(self):
        txt = (
            "Employees (EID, Name, Age) = {\n  E1, John, 32\n  E2, Alice, 28\n  E3, Bob, 29\n}\n"
        )
        rels = parse_definitions(txt)
        q = 'σ (Age > 25 and (Name = "John" or Name = "Bob")) (Employees)'
        res = evaluate(parse_query(q), rels)
        self.assertRelation(res, ["EID", "Name", "Age"], [("E1", "John", 32), ("E3", "Bob", 29)])

    def test_boolean_operator_variants(self):
        txt = (
            "Employees (EID, Name, Age) = {\n  E1, John, 32\n  E2, Alice, 28\n  E3, Bob, 29\n}\n"
        )
        rels = parse_definitions(txt)
        q1 = 'σ (Age > 27 ∧ Name != "Bob") (Employees)'
        res1 = evaluate(parse_query(q1), rels)
        self.assertRelation(res1, ["EID", "Name", "Age"], [("E1", "John", 32), ("E2", "Alice", 28)])
        q2 = 'σ (¬(Age < 30) || Name = "Alice") (Employees)'
        res2 = evaluate(parse_query(q2), rels)
        self.assertRelation(res2, ["EID", "Name", "Age"], [("E1", "John", 32), ("E2", "Alice", 28)])

    def test_null_true_false(self):
        txt = (
            "T (K, Active, Val) = {\n  a, true, 1\n  b, false, 2\n  c, true, null\n}\n"
        )
        rels = parse_definitions(txt)
        res = evaluate(parse_query("σ Active = true (T)"), rels)
        self.assertRelation(res, ["K", "Active", "Val"], [("a", True, 1), ("c", True, None)])
        res = evaluate(parse_query("σ Val = null (T)"), rels)
        self.assertRelation(res, ["K", "Active", "Val"], [("c", True, None)])

    def test_cross_product_when_no_common_attrs(self):
        txt = (
            "L (A) = {\n  1\n  2\n}\n"
            "R (B) = {\n  x\n}\n"
        )
        rels = parse_definitions(txt)
        res = evaluate(parse_query("L ⋈ R"), rels)
        self.assertRelation(res, ["A", "B"], [(1, "x"), (2, "x")])

    def test_projection_missing_attr_raises(self):
        txt = "R (A) = {\n  1\n}\n"
        rels = parse_definitions(txt)
        with self.assertRaises(KeyError):
            evaluate(parse_query("π B (R)"), rels)

    def test_unknown_relation_raises(self):
        txt = "R (A) = {\n  1\n}\n"
        rels = parse_definitions(txt)
        with self.assertRaises(KeyError):
            evaluate(parse_query("S"), rels)

    def test_row_arity_mismatch_raises(self):
        txt = (
            "R (A, B) = {\n  1\n}\n"
        )
        with self.assertRaises(Exception):
            parse_definitions(txt)

    def test_csv_quoted_values_with_commas(self):
        txt = (
            "Cities (ID, Name) = {\n"
            "  1, \"New York, NY\"\n"
            "  2, \"Los Angeles\"\n"
            "}\n"
        )
        rels = parse_definitions(txt)
        rel = rels["Cities"]
        self.assertRelation(rel, ["ID", "Name"], [(1, "New York, NY"), (2, "Los Angeles")])


if __name__ == "__main__":
    unittest.main()
